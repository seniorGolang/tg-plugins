// Copyright (c) 2020 Khramtsov Aleksei (seniorGolang@gmail.com).
// This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this project source code.
package renderer

import (
	"tgp/plugins/client-ts/tsg"

	"fmt"
	"path"

	"tgp/core"
)

// renderHTTPClient генерирует HTTP клиент для контракта
// RenderHTTPClientClass генерирует HTTP клиент для контракта
func (r *ClientRenderer) RenderHTTPClientClass(contract *core.Contract) (err error) {
	logger := core.GetLogger()

	// Отладка: проверяем входные данные
	if contract == nil {
		logger.Error("RenderHTTPClientClass: contract is nil")
		return fmt.Errorf("contract is nil")
	}
	if contract.PkgPath == "" {
		logger.Error(fmt.Sprintf("RenderHTTPClientClass: contract.PkgPath is empty for contract %s", contract.Name))
		return fmt.Errorf("contract.PkgPath is empty for contract %s", contract.Name)
	}
	logger.Debug(fmt.Sprintf("RenderHTTPClientClass: contract=%s, pkgPath=%s", contract.Name, contract.PkgPath))

	outDir := r.outDir
	r.contract = contract
	r.knownTypes = make(map[string]int)
	r.typeDefTs = make(map[string]typeDefTs)

	file := tsg.NewFile()
	file.Comment("// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.\n")

	// Импорты
	file.ImportNamed("./client", "Client")

	file.Line()

	// Сначала собираем все типы, вызывая walkVariable для всех методов
	// Это заполнит typeDefTs всеми необходимыми типами
	for _, method := range contract.Methods {
		if !r.isHTTP(method, contract) {
			continue
		}
		// Собираем типы из аргументов
		args := r.argsWithoutContext(method)
		for _, arg := range args {
			_ = r.walkVariable(arg.Name, contract.PkgPath, arg, method.Annotations, true)
		}
		// Собираем типы из результатов
		results := r.resultsWithoutError(method)
		for _, ret := range results {
			_ = r.walkVariable(ret.Name, contract.PkgPath, ret, method.Annotations, false)
		}
	}

	// Импортируем exchange типы (после сбора типов, чтобы знать какие типы из dto нужны)
	exchangePath := fmt.Sprintf("./%s-exchange", r.tsFileName(contract))
	exchangeTypes := make([]string, 0, len(contract.Methods)*2)
	seenTypes := make(map[string]bool)
	// Импортируем Request и Response типы для HTTP методов
	// Request типы - только для методов с параметрами
	// Response типы - только для методов с результатами
	for _, method := range contract.Methods {
		if !r.isHTTP(method, contract) {
			continue
		}
		args := r.argsWithoutContext(method)
		if len(args) > 0 {
			requestType := r.requestTypeName(contract, method)
			if !seenTypes[requestType] {
				exchangeTypes = append(exchangeTypes, requestType)
				seenTypes[requestType] = true
			}
		}
		results := r.resultsWithoutError(method)
		if len(results) > 0 {
			responseType := r.responseTypeName(contract, method)
			if !seenTypes[responseType] {
				exchangeTypes = append(exchangeTypes, responseType)
				seenTypes[responseType] = true
			}
		}
	}
	// НЕ импортируем типы из namespace dto отдельно - они используются через namespace dto (dto.SomeStruct)
	// Типы из dto доступны через import * as dto, поэтому не нужно импортировать их по отдельности
	// Импортируем exchange типы
	if len(exchangeTypes) > 0 {
		file.ImportType(exchangePath, exchangeTypes...)
	}
	// Импортируем namespace dto для использования dto.SomeStruct и т.д.
	hasDtoTypes := false
	for _, def := range r.typeDefTs {
		if def.importPkg == "dto" {
			hasDtoTypes = true
			break
		}
	}
	if hasDtoTypes {
		file.ImportAll(exchangePath, "dto")
	}

	// Группируем типы по пакетам для генерации namespace
	// Пропускаем типы, которые импортируются из exchange файла
	importedTypes := make(map[string]bool)
	for _, typeName := range exchangeTypes {
		importedTypes[typeName] = true
	}

	typeByPackage := make(map[string][]typeDefTs)
	var standaloneTypes []typeDefTs

	for _, def := range r.typeDefTs {
		// Пропускаем типы, которые импортируются из exchange
		typeName := def.importName
		if typeName == "" {
			typeName = def.name
		}
		if importedTypes[typeName] {
			continue
		}
		// Пропускаем типы из namespace dto, так как они импортируются из exchange
		if def.importPkg == "dto" {
			continue
		}

		if def.importPkg != "" {
			// Тип из другого пакета - группируем по пакету
			typeByPackage[def.importPkg] = append(typeByPackage[def.importPkg], def)
		} else {
			// Обычный тип - генерируем отдельно
			standaloneTypes = append(standaloneTypes, def)
		}
	}

	// Сначала генерируем обычные типы
	for _, def := range standaloneTypes {
		file.Add(r.renderTypeDef(def))
		file.Line()
	}

	// Затем генерируем namespace для каждого пакета
	for pkgName, types := range typeByPackage {
		file.Add(r.renderNamespace(pkgName, types))
		file.Line()
	}

	// Собираем все ошибки для всех методов и генерируем их типы
	allErrorsMap := make(map[string]errorInfo)
	for _, method := range contract.Methods {
		if !r.isHTTP(method, contract) {
			continue
		}
		methodErrors := r.collectMethodErrors(method, contract)
		for key, errInfo := range methodErrors {
			if _, exists := allErrorsMap[key]; !exists {
				allErrorsMap[key] = errInfo
			}
		}
	}

	// Генерируем типы ошибок
	for _, errInfo := range allErrorsMap {
		file.Add(r.renderErrorType(errInfo))
		file.Line()
	}

	// Генерируем union типы для ошибок каждого метода
	for _, method := range contract.Methods {
		if !r.isHTTP(method, contract) {
			continue
		}
		methodErrors := r.collectMethodErrors(method, contract)
		if len(methodErrors) > 0 {
			unionType := r.renderErrorUnionType(method.Name, methodErrors)
			if unionType != nil {
				file.Add(unionType)
				file.Line()
			}
		}
	}

	// Генерируем класс клиента
	clientClass := r.renderHTTPClientClass(contract)
	file.Add(clientClass)
	file.Line()

	// Генерируем импорты
	file.GenerateImports()

	outFilename := path.Join(outDir, fmt.Sprintf("%s-http.ts", r.tsFileName(contract)))
	return file.Save(outFilename)
}

// renderHTTPClientClass генерирует класс HTTP клиента
func (r *ClientRenderer) renderHTTPClientClass(contract *core.Contract) *tsg.Statement {
	// Сохраняем contract в локальную переменную для использования в замыкании
	// Это гарантирует, что contract не будет изменен между установкой r.contract и использованием в замыкании
	currentContract := contract
	logger := core.GetLogger()
	logger.Debug(fmt.Sprintf("renderHTTPClientClass: contract=%s, pkgPath=%s, r.contract=%v", currentContract.Name, currentContract.PkgPath, r.contract != nil))

	stmt := tsg.NewStatement()
	stmt.Comment(fmt.Sprintf("HTTP клиент для сервиса %s", contract.Name))
	stmt.Export().Class(contract.Name+"HTTPClient", func(grp *tsg.Group) {
		// Приватное поле для базового клиента
		grp.Add(tsg.NewStatement().Private().Id("baseClient").Colon().Id("Client").Semicolon())
		grp.Line()

		// Конструктор принимает базовый Client
		constructor := tsg.NewStatement()
		constructor.Comment(fmt.Sprintf("Creates a new HTTP client for %s service", contract.Name))
		constructorStmt := tsg.NewStatement()
		constructorStmt.Id("constructor")
		constructorStmt.Params(func(cg *tsg.Group) {
			cg.Add(tsg.NewStatement().Id("_baseClient").Colon().Id("Client"))
		})
		constructorStmt.BlockFunc(func(cg *tsg.Group) {
			cg.Add(tsg.NewStatement().This().Dot("baseClient").Op("=").Id("_baseClient").Semicolon())
		})
		grp.Add(constructorStmt)
		grp.Line()

		// Методы для каждого HTTP метода контракта
		// Используем currentContract, чтобы гарантировать, что contract не изменен
		// Также убеждаемся, что r.contract установлен перед вызовом renderHTTPMethod
		if r.contract == nil {
			logger.Error("renderHTTPClientClass: r.contract is nil in closure")
			return
		}
		logger.Debug(fmt.Sprintf("renderHTTPClientClass: in closure, r.contract=%s, pkgPath=%s", r.contract.Name, r.contract.PkgPath))
		for _, method := range currentContract.Methods {
			if !r.isHTTP(method, currentContract) {
				continue
			}
			r.renderHTTPMethod(grp, method, currentContract)
		}
	})
	stmt.Export()
	return stmt
}
