// Copyright (c) 2020 Khramtsov Aleksei (seniorGolang@gmail.com).
// This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this project source code.
package renderer

import (
	"tgp/plugins/client-ts/tsg"

	"fmt"
	"path"
	"strings"

	"tgp/shared"
)

// renderExchangeTS генерирует exchange типы для TypeScript (request/response для каждого метода)
// RenderExchangeTypes генерирует exchange типы (request/response) для контракта
func (r *ClientRenderer) RenderExchangeTypes(contract *shared.Contract) (err error) {
	outDir := r.outDir
	r.contract = contract
	// Инициализируем карты для типов
	r.knownTypes = make(map[string]int)
	r.typeDefTs = make(map[string]typeDefTs)

	// Сначала собираем все типы, вызывая walkVariable для всех методов
	// Exchange типы используются и для JSON-RPC, и для HTTP методов
	// Это заполнит typeDefTs всеми необходимыми типами
	for _, method := range contract.Methods {
		// Собираем типы из аргументов
		args := r.argsWithoutContext(method)
		for _, arg := range args {
			_ = r.walkVariable(arg.Name, contract.PkgPath, arg, method.Annotations, true)
		}
		// Собираем типы из результатов
		results := r.resultsWithoutError(method)
		for _, ret := range results {
			_ = r.walkVariable(ret.Name, contract.PkgPath, ret, method.Annotations, false)
		}
	}

	file := tsg.NewFile()
	file.Comment("// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.\n")
	file.Line()

	// Группируем типы по пакетам для генерации namespace
	typeByPackage := make(map[string]map[string]typeDefTs) // pkg -> name -> def
	var standaloneTypes []typeDefTs
	seenStandalone := make(map[string]bool)

	for key, def := range r.typeDefTs {
		if def.importPkg != "" {
			// Тип из другого пакета - группируем по пакету
			if typeByPackage[def.importPkg] == nil {
				typeByPackage[def.importPkg] = make(map[string]typeDefTs)
			}
			// Используем importName для дедупликации
			typeName := def.importName
			if typeName == "" {
				typeName = def.name
			}
			// Сохраняем только один раз по имени типа в пакете
			// Если тип уже существует, но новый имеет больше полей, заменяем его
			existing, exists := typeByPackage[def.importPkg][typeName]
			switch {
			case !exists:
				typeByPackage[def.importPkg][typeName] = def
			case len(def.properties) > len(existing.properties):
				// Если новый тип имеет больше полей, заменяем старый
				typeByPackage[def.importPkg][typeName] = def
			case len(def.properties) == 0 && len(existing.properties) > 0:
				// Если новый тип без полей, а старый с полями - не заменяем
				// (это может быть случай, когда структура была обработана до обработки полей)
			default:
				// В остальных случаях заменяем (новый тип может быть более полным)
				typeByPackage[def.importPkg][typeName] = def
			}
		} else if !seenStandalone[key] {
			// Обычный тип - генерируем отдельно, избегая дубликатов
			standaloneTypes = append(standaloneTypes, def)
			seenStandalone[key] = true
		}
	}

	// Сначала генерируем обычные типы
	for _, def := range standaloneTypes {
		file.Add(r.renderTypeDef(def))
		file.Line()
	}

	// Затем генерируем namespace для каждого пакета
	// Отслеживаем экспортированные типы, чтобы избежать дубликатов
	exportedTypes := make(map[string]bool)
	for pkgName, typesMap := range typeByPackage {
		typesList := make([]typeDefTs, 0, len(typesMap))
		for _, def := range typesMap {
			typesList = append(typesList, def)
		}
		file.Add(r.renderNamespace(pkgName, typesList))
		file.Line()
		// Экспортируем типы из namespace для использования в других файлах
		// Избегаем дубликатов: если тип с таким именем уже экспортирован, пропускаем
		for _, def := range typesList {
			interfaceName := def.importName
			if interfaceName == "" {
				interfaceName = def.name
			}
			if interfaceName != "" {
				// Проверяем, не экспортирован ли уже тип с таким именем
				if exportedTypes[interfaceName] {
					continue
				}
				exportedTypes[interfaceName] = true
				switch def.kind {
				case "struct":
					exportStmt := tsg.NewStatement()
					exportStmt.Export().TypeAlias(interfaceName)
					exportStmt.Id(pkgName).Dot(interfaceName).Semicolon()
					file.Add(exportStmt)
					file.Line()
				case "scalar":
					// Экспортируем типы алиасов (scalar типы)
					exportStmt := tsg.NewStatement()
					exportStmt.Export().TypeAlias(interfaceName)
					exportStmt.Id(pkgName).Dot(interfaceName).Semicolon()
					file.Add(exportStmt)
					file.Line()
				}
			}
		}
	}

	// Генерируем exchange типы для всех методов (JSON-RPC и HTTP)
	// Exchange типы используются для типизации request/response в обоих типах клиентов
	for _, method := range contract.Methods {
		// Request тип
		requestType := r.renderExchangeRequestType(contract, method)
		file.Add(requestType)
		file.Line()

		// Response тип
		responseType := r.renderExchangeResponseType(contract, method)
		file.Add(responseType)
		file.Line()
	}

	// Генерируем импорты (если они были добавлены)
	file.GenerateImports()

	outFilename := path.Join(outDir, fmt.Sprintf("%s-exchange.ts", r.tsFileName(contract)))
	return file.Save(outFilename)
}

// renderExchangeRequestType генерирует тип request для метода
func (r *ClientRenderer) renderExchangeRequestType(contract *shared.Contract, method *shared.Method) *tsg.Statement {
	requestName := r.requestTypeName(contract, method)

	stmt := tsg.NewStatement()

	// JSDoc комментарий
	filteredDocs := r.filterDocsComments(method.Docs)
	if len(filteredDocs) > 0 {
		stmt.Comment(fmt.Sprintf("Request type for %s.%s", contract.Name, method.Name))
		stmt.Comment(strings.Join(filteredDocs, "\n"))
	} else {
		stmt.Comment(fmt.Sprintf("Request type for %s.%s", contract.Name, method.Name))
	}

	args := r.argsWithoutContext(method)
	if len(args) == 0 {
		// Пустой request тип
		stmt.Comment("Formal exchange type, please do not delete.")
		stmt.Export().TypeAlias(requestName)
		stmt.Id("Record").Generic("string", "never")
		stmt.Semicolon()
	} else {
		// Создаём интерфейс с полями
		stmt.Export().Interface(requestName, func(grp *tsg.Group) {
			for _, arg := range args {
				typeStr := r.walkVariable(arg.Name, contract.PkgPath, arg, method.Annotations, true).typeLink()

				field := tsg.NewStatement()
				field.Id(arg.Name)
				if r.contains(method.Annotations, "nullable") {
					field.Optional()
				}
				field.Colon()
				field.Add(tsg.TypeFromString(typeStr))
				field.Semicolon()
				grp.Add(field)
			}
		})
	}
	return stmt
}

// renderExchangeResponseType генерирует тип response для метода
func (r *ClientRenderer) renderExchangeResponseType(contract *shared.Contract, method *shared.Method) *tsg.Statement {
	responseName := r.responseTypeName(contract, method)

	stmt := tsg.NewStatement()

	// JSDoc комментарий
	filteredDocs := r.filterDocsComments(method.Docs)
	if len(filteredDocs) > 0 {
		stmt.Comment(fmt.Sprintf("Response type for %s.%s", contract.Name, method.Name))
		stmt.Comment(strings.Join(filteredDocs, "\n"))
	} else {
		stmt.Comment(fmt.Sprintf("Response type for %s.%s", contract.Name, method.Name))
	}

	results := r.resultsWithoutError(method)
	switch len(results) {
	case 0:
		// Пустой response тип
		stmt.Comment("Formal exchange type, please do not delete.")
		stmt.Export().TypeAlias(responseName)
		stmt.Void()
		stmt.Semicolon()
	case 1:
		// Одно поле - возвращаем его тип напрямую
		typeStr := r.walkVariable(results[0].Name, contract.PkgPath, results[0], method.Annotations, false).typeLink()
		stmt.Export().TypeAlias(responseName)
		stmt.Add(tsg.TypeFromString(typeStr))
		stmt.Semicolon()
	default:
		// Несколько полей - создаём интерфейс
		stmt.Export().Interface(responseName, func(grp *tsg.Group) {
			for _, ret := range results {
				typeStr := r.walkVariable(ret.Name, contract.PkgPath, ret, method.Annotations, false).typeLink()

				field := tsg.NewStatement()
				field.Id(ret.Name)
				if r.contains(method.Annotations, "nullable") {
					field.Optional()
				}
				field.Colon()
				field.Add(tsg.TypeFromString(typeStr))
				field.Semicolon()
				grp.Add(field)
			}
		})
	}
	return stmt
}

// filterDocsComments фильтрует аннотации @tg из документации
func (r *ClientRenderer) filterDocsComments(docs []string) []string {
	if len(docs) == 0 {
		return docs
	}
	var filtered []string
	for _, doc := range docs {
		// Пропускаем строки с аннотациями @tg
		if !strings.Contains(doc, "@tg") {
			filtered = append(filtered, doc)
		}
	}
	return filtered
}

// argsWithoutContext возвращает аргументы метода без context.Context
func (r *ClientRenderer) argsWithoutContext(method *shared.Method) []*shared.Variable {
	args := make([]*shared.Variable, 0, len(method.Args))
	for _, arg := range method.Args {
		// Пропускаем context.Context
		if arg.TypeID == "context:Context" || arg.TypeID == "context.Context" {
			continue
		}
		args = append(args, arg)
	}
	return args
}

// resultsWithoutError возвращает результаты метода без error
func (r *ClientRenderer) resultsWithoutError(method *shared.Method) []*shared.Variable {
	results := make([]*shared.Variable, 0, len(method.Results))
	for _, result := range method.Results {
		// Пропускаем error
		if result.TypeID == "error" || result.TypeID == "builtin:error" {
			continue
		}
		results = append(results, result)
	}
	return results
}

// renderTypeDef генерирует определение типа TypeScript
func (r *ClientRenderer) renderTypeDef(def typeDefTs) *tsg.Statement {
	stmt := tsg.NewStatement()

	switch def.kind {
	case "constant":
		if len(def.properties) > 1 {
			if def.typeName == "iota" {
				var cnt int
				for key := range def.properties {
					stmt.Add(tsg.NewStatement().Const(key).Op("=").Lit(cnt).Semicolon().Export())
					cnt++
				}
			} else {
				stmt.Add(
					tsg.NewStatement().
						Id("enum").
						Id(def.typeName).
						Values(func(grp *tsg.Group) {
							for key := range def.properties {
								grp.Add(tsg.NewStatement().Id(key).Semicolon())
							}
						}).
						Export(),
				)
			}
		} else {
			stmt.Add(tsg.NewStatement().Const(def.name).Op("=").Lit(def.value).Semicolon().Export())
		}
	case "struct":
		stmt.Comment(fmt.Sprintf("Тип %s", def.name))
		stmt.Interface(def.name, func(grp *tsg.Group) {
			for name, property := range def.properties {
				typeStr := castTypeTs(property.def())
				field := tsg.NewStatement().
					Id(name)
				if property.nullable {
					field.Optional()
				}
				grp.Add(field.Colon().Add(tsg.TypeFromString(typeStr)).Semicolon())
			}
		})
		stmt.Export()
	}

	return stmt
}

// renderNamespace генерирует namespace для пакета с типами
func (r *ClientRenderer) renderNamespace(pkgName string, types []typeDefTs) *tsg.Statement {
	stmt := tsg.NewStatement()
	stmt.Export().Namespace(pkgName, func(grp *tsg.Group) {
		for _, def := range types {
			// Используем importName, если есть, иначе name
			interfaceName := def.importName
			if interfaceName == "" {
				interfaceName = def.name
			}
			// Если имя все еще пустое, пытаемся извлечь из ключа typeDefTs
			// Ключ имеет формат "pkg:typeName" для импортированных типов
			if interfaceName == "" {
				// Ищем тип в typeDefTs по ключу
				for key, d := range r.typeDefTs {
					if d.importPkg == pkgName && d.importName != "" {
						interfaceName = d.importName
						break
					}
					// Проверяем формат "pkg:typeName"
					if strings.HasPrefix(key, pkgName+":") {
						parts := strings.SplitN(key, ":", 2)
						if len(parts) == 2 {
							interfaceName = parts[1]
							break
						}
					}
				}
			}
			if interfaceName == "" {
				// Пропускаем типы без имени
				continue
			}
			switch def.kind {
			case "struct":
				// Генерируем интерфейс внутри namespace
				ifStmt := tsg.NewStatement()
				ifStmt.Interface(interfaceName, func(ig *tsg.Group) {
					for name, property := range def.properties {
						typeStr := castTypeTs(property.def())
						field := tsg.NewStatement().
							Id(name)
						if property.nullable {
							field.Optional()
						}
						ig.Add(field.Colon().Add(tsg.TypeFromString(typeStr)).Semicolon())
					}
				})
				ifStmt.Export()
				grp.Add(ifStmt)
			case "map":
				// Генерируем type alias для именованных map типов (например, ExtendedFields)
				// Используем Record<key, value> как базовый тип
				keyType := def.properties["key"]
				valueType := def.properties["value"]
				typeAliasStmt := tsg.NewStatement()
				typeAliasStmt.TypeAlias(interfaceName)
				// Генерируем Record<keyType, valueType>
				recordType := fmt.Sprintf("Record<%s, %s>", castTypeTs(keyType.typeLink()), castTypeTs(valueType.typeLink()))
				typeAliasStmt.Add(tsg.TypeFromString(recordType))
				typeAliasStmt.Semicolon()
				typeAliasStmt.Export()
				grp.Add(typeAliasStmt)
			case "scalar":
				// Генерируем type alias для скалярных типов (алиасов Go)
				// Используем базовый TypeScript тип из typeName (например, "number" для int64, "string" для string)
				// Важно: используем def.typeName, который уже содержит правильный TypeScript тип (number, string, boolean)
				typeAliasStmt := tsg.NewStatement()
				typeAliasStmt.TypeAlias(interfaceName)
				// def.typeName уже содержит правильный TypeScript тип (number, string, boolean и т.д.)
				typeAliasStmt.Add(tsg.TypeFromString(def.typeName))
				typeAliasStmt.Semicolon()
				typeAliasStmt.Export()
				grp.Add(typeAliasStmt)
			}
		}
	})
	return stmt
}
