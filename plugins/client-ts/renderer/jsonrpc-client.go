// Copyright (c) 2020 Khramtsov Aleksei (seniorGolang@gmail.com).
// This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this project source code.
package renderer

import (
	"tgp/plugins/client-ts/tsg"

	"fmt"
	"path"
	"strings"

	"tgp/core"
)

// renderJsonRPCClient генерирует JSON-RPC клиент для контракта
// RenderJsonRPCClientClass генерирует JSON-RPC клиент для контракта
func (r *ClientRenderer) RenderJsonRPCClientClass(contract *core.Contract) (err error) {
	logger := core.GetLogger()

	// Отладка: проверяем входные данные
	if contract == nil {
		logger.Error("RenderJsonRPCClientClass: contract is nil")
		return fmt.Errorf("contract is nil")
	}
	if contract.PkgPath == "" {
		logger.Error(fmt.Sprintf("RenderJsonRPCClientClass: contract.PkgPath is empty for contract %s", contract.Name))
		return fmt.Errorf("contract.PkgPath is empty for contract %s", contract.Name)
	}
	logger.Debug(fmt.Sprintf("RenderJsonRPCClientClass: contract=%s, pkgPath=%s", contract.Name, contract.PkgPath))

	outDir := r.outDir
	r.contract = contract
	r.knownTypes = make(map[string]int)
	r.typeDefTs = make(map[string]typeDefTs)

	file := tsg.NewFile()
	file.Comment("// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.\n")

	// Импорты
	file.ImportNamed("./client", "Client")
	file.ImportNamed("./jsonrpc/client", "JsonRpcClient")
	file.ImportNamed("./jsonrpc/utils/jsonrpc", "JsonRpcCall")
	file.ImportType("./jsonrpc/utils/jsonrpc", "JsonRpcParams", "ResponseRPC")
	file.ImportType("./jsonrpc/utils/ts", "MapBatchResult")
	file.ImportType("./batch", "BatchRequest")

	// Сначала собираем все типы, вызывая walkVariable для всех методов
	// Это заполнит typeDefTs всеми необходимыми типами
	for _, method := range contract.Methods {
		// Собираем типы из аргументов
		args := r.argsWithoutContext(method)
		for _, arg := range args {
			_ = r.walkVariable(arg.Name, contract.PkgPath, arg, method.Annotations, true)
		}
		// Собираем типы из результатов
		results := r.resultsWithoutError(method)
		for _, ret := range results {
			_ = r.walkVariable(ret.Name, contract.PkgPath, ret, method.Annotations, false)
		}
	}

	// Импортируем exchange типы (после сбора типов, чтобы знать какие типы из dto нужны)
	exchangePath := fmt.Sprintf("./%s-exchange", r.tsFileName(contract))
	exchangeTypes := make([]string, 0, len(contract.Methods)*2)
	seenTypes := make(map[string]bool)
	// Импортируем Request и Response типы только для JSON-RPC методов
	// Request типы - только для методов с параметрами
	// Response типы - только для методов с результатами
	for _, method := range contract.Methods {
		if !r.methodIsJsonRPC(contract, method) {
			continue
		}
		args := r.argsWithoutContext(method)
		if len(args) > 0 {
			requestType := r.requestTypeName(contract, method)
			if !seenTypes[requestType] {
				exchangeTypes = append(exchangeTypes, requestType)
				seenTypes[requestType] = true
			}
		}
		results := r.resultsWithoutError(method)
		if len(results) > 0 {
			responseType := r.responseTypeName(contract, method)
			if !seenTypes[responseType] {
				exchangeTypes = append(exchangeTypes, responseType)
				seenTypes[responseType] = true
			}
		}
	}
	// НЕ импортируем типы из namespace dto отдельно - они используются через namespace dto (dto.SomeStruct)
	// Типы из dto доступны через import * as dto, поэтому не нужно импортировать их по отдельности
	if len(exchangeTypes) > 0 {
		file.ImportType(exchangePath, exchangeTypes...)
	}
	// Импортируем namespace dto для использования dto.SomeStruct и т.д.
	// Проверяем, есть ли типы из namespace dto
	hasDtoTypes := false
	for _, def := range r.typeDefTs {
		if def.importPkg == "dto" {
			hasDtoTypes = true
			break
		}
	}
	if hasDtoTypes {
		file.ImportAll(exchangePath, "dto")
	}

	// Генерируем импорты
	file.GenerateImports()
	file.Line()

	// Генерируем типы данных (константы, enums, интерфейсы)
	// Пропускаем типы, которые импортируются из exchange файла
	importedTypes := make(map[string]bool)
	for _, typeName := range exchangeTypes {
		importedTypes[typeName] = true
	}
	for _, def := range r.typeDefTs {
		// Пропускаем типы, которые импортируются из exchange
		typeName := def.importName
		if typeName == "" {
			typeName = def.name
		}
		if importedTypes[typeName] {
			continue
		}
		// Пропускаем типы из namespace dto, так как они импортируются из exchange
		if def.importPkg == "dto" {
			continue
		}
		file.Add(r.renderTypeDef(def))
		file.Line()
	}

	// Собираем все ошибки для всех методов и генерируем их типы
	allErrorsMap := make(map[string]errorInfo)
	for _, method := range contract.Methods {
		methodErrors := r.collectMethodErrors(method, contract)
		for key, errInfo := range methodErrors {
			if _, exists := allErrorsMap[key]; !exists {
				allErrorsMap[key] = errInfo
			}
		}
	}

	// Генерируем типы ошибок
	for _, errInfo := range allErrorsMap {
		file.Add(r.renderErrorType(errInfo))
		file.Line()
	}

	// Генерируем union типы для ошибок каждого метода
	for _, method := range contract.Methods {
		methodErrors := r.collectMethodErrors(method, contract)
		if len(methodErrors) > 0 {
			unionType := r.renderErrorUnionType(method.Name, methodErrors)
			if unionType != nil {
				file.Add(unionType)
				file.Line()
			}
		}
	}

	// Генерируем типы для callback функций (только для JSON-RPC методов) - ВНЕ класса
	for _, method := range contract.Methods {
		if r.methodIsJsonRPC(contract, method) {
			// Тип callback функции: (results... | null, error: Error | null) => void
			// Современный подход: результат может быть null при ошибке
			results := r.resultsWithoutError(method)
			callbackTypeStmt := tsg.NewStatement()
			callbackTypeStmt.Export().Type("ret" + contract.Name + method.Name)
			callbackTypeStmt.Op("=")
			callbackFnType := tsg.NewStatement()
			callbackFnType.Params(func(fg *tsg.Group) {
				for _, ret := range results {
					typeStr := r.walkVariable(ret.Name, contract.PkgPath, ret, method.Annotations, false).typeLink()
					// Делаем результат nullable для поддержки случая ошибки
					nullableType := tsg.NewStatement()
					nullableType.Add(tsg.TypeFromString(typeStr)).Op("|").Id("null")
					fg.Add(tsg.NewStatement().Id(ret.Name).Colon().Add(nullableType))
				}
				fg.Add(tsg.NewStatement().Id("error").Colon().Id("Error").Op("|").Id("null"))
			}).Op("=>").Id("void")
			callbackTypeStmt.Add(callbackFnType).Semicolon()
			file.Add(callbackTypeStmt)
			file.Line()
		}
	}

	// Генерируем класс клиента
	clientClass := r.renderJsonRPCClientClass(contract)
	file.Add(clientClass)
	file.Line()

	outFilename := path.Join(outDir, fmt.Sprintf("%s.ts", r.tsFileName(contract)))
	return file.Save(outFilename)
}

// renderJsonRPCClientClass генерирует класс JSON-RPC клиента
func (r *ClientRenderer) renderJsonRPCClientClass(contract *core.Contract) *tsg.Statement {
	// Сохраняем contract в локальную переменную для использования в замыкании
	// Это гарантирует, что contract не будет изменен между установкой r.contract и использованием в замыкании
	currentContract := contract
	logger := core.GetLogger()
	logger.Debug(fmt.Sprintf("renderJsonRPCClientClass: contract=%s, pkgPath=%s, r.contract=%v", currentContract.Name, currentContract.PkgPath, r.contract != nil))

	stmt := tsg.NewStatement()
	stmt.Comment(fmt.Sprintf("JSON-RPC client for %s service", contract.Name))
	filteredSvcDocs := r.filterDocsComments(contract.Docs)
	if len(filteredSvcDocs) > 0 {
		stmt.Comment(strings.Join(filteredSvcDocs, "\n"))
	}
	stmt.Export().Class(contract.Name+"Client", func(grp *tsg.Group) {
		// Приватное поле для базового клиента
		grp.Add(tsg.NewStatement().Private().Id("baseClient").Colon().Id("Client").Semicolon())
		// Приватное поле для JSON-RPC клиента
		grp.Add(tsg.NewStatement().Private().Id("client").Colon().Id("JsonRpcClient").Semicolon())
		grp.Line()

		// Конструктор принимает базовый Client
		constructor := tsg.NewStatement()
		constructor.Comment(fmt.Sprintf("Creates a new JSON-RPC client for %s service", contract.Name))
		constructorStmt := tsg.NewStatement()
		constructorStmt.Id("constructor")
		constructorStmt.Params(func(cg *tsg.Group) {
			cg.Add(tsg.NewStatement().Id("_baseClient").Colon().Id("Client"))
		})
		constructorStmt.BlockFunc(func(cg *tsg.Group) {
			cg.Add(tsg.NewStatement().This().Dot("baseClient").Op("=").Id("_baseClient").Semicolon())
			// Используем RPC клиент из базового клиента
			cg.Add(tsg.NewStatement().This().Dot("client").Op("=").Id("_baseClient").Dot("getRpcClient").Call().Semicolon())
		})
		grp.Add(constructorStmt)
		grp.Line()

		// Методы для каждого JSON-RPC метода контракта
		// Используем currentContract и убеждаемся, что r.contract установлен
		if r.contract == nil {
			logger.Error("renderJsonRPCClientClass: r.contract is nil in closure")
			return
		}
		logger.Debug(fmt.Sprintf("renderJsonRPCClientClass: in closure, r.contract=%s, pkgPath=%s", r.contract.Name, r.contract.PkgPath))

		// Генерируем методы для каждого JSON-RPC метода контракта
		for _, method := range currentContract.Methods {
			if r.methodIsJsonRPC(currentContract, method) {
				r.renderJsonRPCMethod(grp, currentContract, method)
				r.renderJsonRPCRequestMethod(grp, currentContract, method)
			}
		}

		// Метод для батч запросов
		r.renderJsonRPCBatchMethod(grp, contract)
	})
	stmt.Export()
	return stmt
}

// renderJsonRPCMethod генерирует метод JSON-RPC клиента
func (r *ClientRenderer) renderJsonRPCMethod(grp *tsg.Group, contract *core.Contract, method *core.Method) {
	// JSDoc комментарий
	filteredDocs := r.filterDocsComments(method.Docs)
	if len(filteredDocs) > 0 {
		grp.Comment(strings.Join(filteredDocs, "\n"))
	} else {
		grp.Comment(fmt.Sprintf("Calls %s.%s method", contract.Name, method.Name))
	}

	args := r.argsWithoutContext(method)
	results := r.resultsWithoutError(method)

	// Создаём параметры метода
	methodParams := tsg.NewStatement()
	methodParams.Params(func(pg *tsg.Group) {
		if len(args) > 0 {
			for _, arg := range args {
				typeStr := r.walkVariable(arg.Name, contract.PkgPath, arg, method.Annotations, true).typeLink()
				paramStmt := tsg.NewStatement()
				paramStmt.Id(arg.Name)
				if r.contains(method.Annotations, "nullable") {
					paramStmt.Optional()
				}
				paramStmt.Colon()
				paramStmt.Add(tsg.TypeFromString(typeStr))
				pg.Add(paramStmt)
			}
		}
	})

	// Тип возвращаемого значения
	returnType := r.resultToTypeStatement(method, results)

	// Получаем типы из exchange для внутреннего использования
	requestTypeName := r.requestTypeName(contract, method)
	responseTypeName := r.responseTypeName(contract, method)

	// Создаём async метод (публичный метод класса)
	methodStmt := tsg.NewStatement()
	methodStmt.Public()
	methodStmt.AsyncMethodWithParams(r.lcName(method.Name), methodParams, returnType, func(mg *tsg.Group) {
		// Собираем объект params из отдельных параметров
		if len(args) > 0 {
			paramsObj := tsg.NewStatement()
			paramsObj.Const("params").Colon().Id(requestTypeName).Op("=")
			paramsObj.Values(func(vg *tsg.Group) {
				for _, arg := range args {
					vg.Add(tsg.NewStatement().Id(arg.Name).Colon().Id(arg.Name))
				}
			})
			mg.Add(paramsObj.Semicolon())
		} else {
			// Пустые параметры - создаём пустой объект
			mg.Add(tsg.NewStatement().Const("params").Colon().Id("Record").Generic("string", "never").Op("=").Values(nil).Semicolon())
		}

		// const execResult = await this.client.exec('methodName', params);
		methodName := r.lcName(contract.Name) + "." + r.lcName(method.Name)
		execCall := tsg.NewStatement()
		execCall.This().Dot("client").Dot("exec")
		execCall.Call(
			tsg.NewStatement().Lit(methodName),
			tsg.NewStatement().Id("params"),
		)

		mg.Add(
			tsg.NewStatement().
				Const("execResult").
				Op("=").
				Await(execCall).
				Semicolon(),
		)

		// Обработка ошибок с типизацией
		methodErrors := r.collectMethodErrors(method, contract)
		if len(methodErrors) > 0 {
			// Есть типизированные ошибки - используем type guards
			mg.If(
				tsg.NewStatement().
					Id("execResult").
					Dot("type").
					Op("!==").
					Lit("success"),
				func(ig *tsg.Group) {
					// Приводим ошибку к union типу
					unionTypeName := fmt.Sprintf("%sError", method.Name)
					errorVar := tsg.NewStatement()
					errorVar.Const("error").Colon().Id(unionTypeName).Op("=").Id("execResult").Dot("error").Op("as").Id(unionTypeName)
					ig.Add(errorVar.Semicolon())
					ig.Throw(tsg.NewStatement().Id("error"))
				},
			)
		} else {
			// Нет типизированных ошибок - используем стандартную обработку
			mg.If(
				tsg.NewStatement().
					Id("execResult").
					Dot("type").
					Op("!==").
					Lit("success"),
				func(ig *tsg.Group) {
					ig.Throw(tsg.NewStatement().Id("execResult").Dot("error"))
				},
			)
		}

		// Преобразуем response в формат возвращаемого значения
		if len(results) == 0 {
			mg.Return()
		} else {
			mg.Add(tsg.NewStatement().Const("result").Colon().Id(responseTypeName).Op("=").Id("execResult").Dot("result").Op("as").Id(responseTypeName).Semicolon())

			if len(results) == 1 {
				mg.Return(tsg.NewStatement().Id("result"))
			} else {
				returnObj := tsg.NewStatement()
				returnObj.Values(func(rg *tsg.Group) {
					for _, ret := range results {
						rg.Add(tsg.NewStatement().Id(ret.Name).Colon().Id("result").Dot(ret.Name))
					}
				})
				mg.Return(returnObj)
			}
		}
	})
	grp.Add(methodStmt)
	grp.Line()
}

// renderJsonRPCRequestMethod генерирует метод reqMethodName для создания RequestRPC с callback
func (r *ClientRenderer) renderJsonRPCRequestMethod(grp *tsg.Group, contract *core.Contract, method *core.Method) {
	// JSDoc комментарий
	filteredDocs := r.filterDocsComments(method.Docs)
	if len(filteredDocs) > 0 {
		grp.Comment(strings.Join(filteredDocs, "\n"))
	} else {
		grp.Comment(fmt.Sprintf("Creates a RequestRPC for %s.%s method", contract.Name, method.Name))
	}

	args := r.argsWithoutContext(method)

	// Параметры метода: callback и параметры метода
	methodParams := tsg.NewStatement()
	methodParams.Params(func(pg *tsg.Group) {
		// Callback функция
		callbackTypeName := "ret" + contract.Name + method.Name
		pg.Add(tsg.NewStatement().Id("callback").Colon().Id(callbackTypeName))
		// Параметры метода
		if len(args) > 0 {
			for _, arg := range args {
				typeStr := r.walkVariable(arg.Name, contract.PkgPath, arg, method.Annotations, true).typeLink()
				paramStmt := tsg.NewStatement()
				paramStmt.Id(arg.Name)
				if r.contains(method.Annotations, "nullable") {
					paramStmt.Optional()
				}
				paramStmt.Colon()
				paramStmt.Add(tsg.TypeFromString(typeStr))
				pg.Add(paramStmt)
			}
		}
	})

	// Возвращаемый тип: BatchRequest
	returnType := tsg.NewStatement()
	returnType.Id("BatchRequest")

	// Получаем типы из exchange для внутреннего использования
	requestTypeName := r.requestTypeName(contract, method)

	// Создаём метод вручную
	methodStmt := tsg.NewStatement()
	methodStmt.Id("req" + method.Name)
	// Добавляем параметры
	if methodParams != nil {
		// methodParams уже содержит (), просто добавляем его
		methodStmt.Add(methodParams)
	} else {
		methodStmt.Id("()")
	}
	// Добавляем возвращаемый тип
	if returnType != nil {
		methodStmt.Colon().Add(returnType)
	}
	// Добавляем тело метода
	methodStmt.BlockFunc(func(bg *tsg.Group) {
		// Создаём объект params из отдельных параметров
		if len(args) > 0 {
			paramsObj := tsg.NewStatement()
			paramsObj.Const("params").Colon().Id(requestTypeName).Op("=")
			paramsObj.Values(func(vg *tsg.Group) {
				for _, arg := range args {
					vg.Add(tsg.NewStatement().Id(arg.Name).Colon().Id(arg.Name))
				}
			})
			bg.Add(paramsObj.Semicolon())
		} else {
			// Пустые параметры - создаём пустой объект
			bg.Add(tsg.NewStatement().Const("params").Colon().Id("Record").Generic("string", "never").Op("=").Values(nil).Semicolon())
		}

		// Создаём BatchRequest
		requestStmt := tsg.NewStatement()
		requestStmt.Const("_request").Colon().Id("BatchRequest").Op("=")
		requestStmt.Values(func(vg *tsg.Group) {
			// rpcRequest
			rpcRequestStmt := tsg.NewStatement()
			rpcRequestStmt.Id("rpcRequest").Colon()
			rpcRequestStmt.Values(func(rg *tsg.Group) {
				rg.Add(tsg.NewStatement().ObjectField("jsonrpc", tsg.NewStatement().Lit("2.0")))
				rg.Add(tsg.NewStatement().ObjectField("method", tsg.NewStatement().Lit(r.lcName(contract.Name)+"."+r.lcName(method.Name))))
				rg.Add(tsg.NewStatement().ObjectField("params", tsg.NewStatement().Id("params")))
				// Генерируем ID - используем публичный метод
				idGen := tsg.NewStatement()
				idGen.Id("id").Colon().Id("this.baseClient.getRpcClient").Call().Dot("generateId").Call()
				rg.Add(idGen)
			})
			vg.Add(rpcRequestStmt)
			// retHandler устанавливается ниже, если callback передан, иначе undefined
			vg.Add(tsg.NewStatement().ObjectField("retHandler", tsg.NewStatement().Id("undefined")))
		})
		bg.Add(requestStmt.Semicolon())

		// Устанавливаем retHandler если callback не null
		bg.If(
			tsg.NewStatement().Id("callback"),
			func(ig *tsg.Group) {
				// Получаем типы результатов для извлечения из response
				results := r.resultsWithoutError(method)
				responseTypeName := r.responseTypeName(contract, method)

				// Создаём retHandler функцию
				retHandlerStmt := tsg.NewStatement()
				retHandlerStmt.Id("_request.retHandler").Op("=")
				retHandlerFn := tsg.NewStatement()
				// Создаём параметры для стрелочной функции
				arrowParams := tsg.NewStatement()
				arrowParams.Params(func(fg *tsg.Group) {
					fg.Add(tsg.NewStatement().Id("error").Colon().Id("Error").Op("|").Id("null"))
					fg.Add(tsg.NewStatement().Id("rpcResponse").Colon().Id("ResponseRPC").Op("|").Id("null"))
				})
				retHandlerFn.Add(arrowParams).Op("=>")
				retHandlerFn.BlockFunc(func(hg *tsg.Group) {
					// Обрабатываем ответ
					hg.If(
						tsg.NewStatement().Id("error").Op("===").Id("null").Op("&&").Id("rpcResponse"),
						func(ig *tsg.Group) {
							ig.If(
								tsg.NewStatement().Id("rpcResponse.error"),
								func(eg *tsg.Group) {
									// Ошибка JSON-RPC
									errorMsgStmt := tsg.NewStatement()
									errorMsgStmt.Const("errorMsg").Colon().Id("string").Op("=")
									errorMsgStmt.Id("rpcResponse.error").Op("&&").Id("typeof").Call(tsg.NewStatement().Id("rpcResponse.error")).Op("===").Lit("object").Op("&&").Id("rpcResponse.error.message")
									errorMsgStmt.Op("||").Lit("unknown error")
									eg.Add(errorMsgStmt.Semicolon())

									// Вызываем callback с null результатами и error (типы теперь поддерживают null)
									callbackArgs := []*tsg.Statement{}
									for range results {
										callbackArgs = append(callbackArgs, tsg.NewStatement().Id("null"))
									}
									callbackArgs = append(callbackArgs, tsg.NewStatement().New("Error").Call(tsg.NewStatement().Id("errorMsg")))
									eg.Add(tsg.NewStatement().Id("callback").Call(callbackArgs...).Semicolon())
								},
							)
							ig.If(
								tsg.NewStatement().Id("rpcResponse").Op("&&").Op("!").Id("rpcResponse.error"),
								func(sg *tsg.Group) {
									// Успешный ответ - извлекаем результат из rpcResponse.result
									if len(results) == 0 {
										// Нет результатов - вызываем callback только с null error
										sg.Add(tsg.NewStatement().Id("callback").Call(
											tsg.NewStatement().Id("null"),
										).Semicolon())
									} else {
										// Извлекаем результат
										sg.Add(tsg.NewStatement().Const("result").Colon().Id(responseTypeName).Op("=").Id("rpcResponse.result").Op("as").Id(responseTypeName).Semicolon())

										// Вызываем callback с результатами и null error
										callbackArgs := []*tsg.Statement{}
										if len(results) == 1 {
											callbackArgs = append(callbackArgs, tsg.NewStatement().Id("result"))
										} else {
											// Несколько результатов - извлекаем каждое поле
											for _, ret := range results {
												callbackArgs = append(callbackArgs, tsg.NewStatement().Id("result").Dot(ret.Name))
											}
										}
										callbackArgs = append(callbackArgs, tsg.NewStatement().Id("null"))
										sg.Add(tsg.NewStatement().Id("callback").Call(callbackArgs...).Semicolon())
									}
								},
							)
						},
					)
					hg.If(
						tsg.NewStatement().Id("error").Op("||").Op("!").Id("rpcResponse"),
						func(eg *tsg.Group) {
							// Ошибка или null response - вызываем callback с null результатами и error
							// Типы теперь поддерживают null, поэтому type assertion не нужен
							callbackArgs := []*tsg.Statement{}
							for range results {
								callbackArgs = append(callbackArgs, tsg.NewStatement().Id("null"))
							}
							callbackArgs = append(callbackArgs, tsg.NewStatement().Id("error").Op("||").New("Error").Call(tsg.NewStatement().Lit("unknown error")))
							eg.Add(tsg.NewStatement().Id("callback").Call(callbackArgs...).Semicolon())
						},
					)
				})
				retHandlerStmt.Add(retHandlerFn).Semicolon()
				ig.Add(retHandlerStmt)
			},
		)

		// Возвращаем RequestRPC
		bg.Return(tsg.NewStatement().Id("_request"))
	})
	grp.Add(methodStmt)
	grp.Line()
}

// renderJsonRPCBatchMethod генерирует метод для выполнения батч запросов
func (r *ClientRenderer) renderJsonRPCBatchMethod(grp *tsg.Group, contract *core.Contract) {
	grp.Comment("Executes a batch of JSON-RPC requests")
	grp.Comment("@param calls - Array of JSON-RPC calls to execute")

	genericParams := tsg.NewStatement()
	genericParams.Generic("Calls extends readonly JsonRpcCall<JsonRpcParams>[]")

	methodParams := tsg.NewStatement()
	methodParams.Params(func(pg *tsg.Group) {
		pg.Add(tsg.NewStatement().Id("calls").Colon().Id("Calls"))
	})

	returnType := tsg.NewStatement()
	returnType.Id("MapBatchResult").Generic("Calls")

	methodStmt := tsg.NewStatement()
	methodStmt.AsyncMethodWithGeneric("execBatch", genericParams, methodParams, returnType, func(mg *tsg.Group) {
		mg.Return(
			tsg.NewStatement().
				This().
				Dot("client").
				Dot("callBatch").
				Call(tsg.NewStatement().Id("calls")).
				Op("as").
				Id("MapBatchResult").
				Generic("Calls"),
		)
	})
	grp.Add(methodStmt)
	grp.Line()
}

// resultToTypeStatement создаёт тип для результата метода
func (r *ClientRenderer) resultToTypeStatement(method *core.Method, vars []*core.Variable) *tsg.Statement {
	logger := core.GetLogger()

	if len(vars) == 0 {
		return tsg.NewStatement().Id("void")
	}

	// Отладка: проверяем, что r.contract установлен ПЕРЕД обращением к его полям
	// Это критично, так как обращение к nil указателю вызовет панику
	if r.contract == nil {
		logger.Error(fmt.Sprintf("resultToTypeStatement: r.contract is nil for method %s", method.Name))
		// Возвращаем any как fallback, чтобы не паниковать
		return tsg.NewStatement().Id("any")
	}

	// Получаем pkgPath с дополнительной проверкой
	var pkgPath string
	if r.contract != nil {
		pkgPath = r.contract.PkgPath
		if pkgPath == "" {
			logger.Error(fmt.Sprintf("resultToTypeStatement: r.contract.PkgPath is empty for contract %s, method %s", r.contract.Name, method.Name))
			// Возвращаем any как fallback
			return tsg.NewStatement().Id("any")
		}
		logger.Debug(fmt.Sprintf("resultToTypeStatement: method=%s, contract=%s, pkgPath=%s, varsCount=%d", method.Name, r.contract.Name, pkgPath, len(vars)))
	} else {
		logger.Error(fmt.Sprintf("resultToTypeStatement: r.contract is nil after check for method %s", method.Name))
		return tsg.NewStatement().Id("any")
	}

	if len(vars) == 1 {
		// Одно поле - возвращаем его тип напрямую
		logger.Debug(fmt.Sprintf("resultToTypeStatement: processing single var name=%s, typeID=%s, pkgPath=%s", vars[0].Name, vars[0].TypeID, pkgPath))
		schema := r.walkVariable(vars[0].Name, pkgPath, vars[0], method.Annotations, false)
		logger.Debug(fmt.Sprintf("resultToTypeStatement: schema kind=%s, name=%s, typeName=%s", schema.kind, schema.name, schema.typeName))
		typeStr := schema.typeLink()
		logger.Debug(fmt.Sprintf("resultToTypeStatement: typeLink result=%s", typeStr))
		return tsg.TypeFromString(typeStr)
	}

	// Несколько полей - возвращаем объект
	stmt := tsg.NewStatement()
	stmt.Values(func(grp *tsg.Group) {
		for _, ret := range vars {
			logger.Debug(fmt.Sprintf("resultToTypeStatement: processing var name=%s, typeID=%s, pkgPath=%s", ret.Name, ret.TypeID, pkgPath))
			schema := r.walkVariable(ret.Name, pkgPath, ret, method.Annotations, false)
			logger.Debug(fmt.Sprintf("resultToTypeStatement: schema kind=%s, name=%s, typeName=%s", schema.kind, schema.name, schema.typeName))
			typeStr := schema.typeLink()
			logger.Debug(fmt.Sprintf("resultToTypeStatement: typeLink result=%s", typeStr))
			field := tsg.NewStatement()
			field.Id(ret.Name)
			if r.contains(method.Annotations, "nullable") {
				field.Optional()
			}
			field.Colon()
			field.Add(tsg.TypeFromString(typeStr))
			field.Semicolon()
			grp.Add(field)
		}
	})
	return stmt
}
