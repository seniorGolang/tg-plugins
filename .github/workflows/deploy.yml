name: Deploy Plugins

on:
  push:
    tags:
      - 'v*'   # Поддержка тегов формата v{version} для деплоя всех плагинов

permissions:
  contents: write  # Необходимо для создания релизов

jobs:
  # Для тега v{version} - деплоим все плагины
  detect_plugins:
    runs-on: ubuntu-latest
    container: alpine:latest
    if: startsWith(github.ref, 'refs/tags/v')
    outputs:
      plugins: ${{ steps.set_plugins.outputs.plugins }}
      version: ${{ steps.version.outputs.version }}
    steps:
      - uses: actions/checkout@v4
      - name: Install dependencies
        run: apk add --no-cache findutils jq
      - name: Extract version from tag
        id: version
        run: |
          TAG=${GITHUB_REF#refs/tags/}
          case "$TAG" in
            v*)
              PLUGIN_VERSION=${TAG#v}
              ;;
            *)
              echo "Неверный формат тега: $TAG (ожидается v{version})"
              exit 1
              ;;
          esac
          echo "version=$PLUGIN_VERSION" >> $GITHUB_OUTPUT
      - name: Detect plugins
        id: set_plugins
        run: |
          PLUGINS=$(find plugins -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | sort)
          JSON_PLUGINS=$(echo "$PLUGINS" | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "plugins=$JSON_PLUGINS" >> $GITHUB_OUTPUT

  build_all:
    needs: detect_plugins
    runs-on: ubuntu-latest
    container: golang:1.25-alpine
    if: startsWith(github.ref, 'refs/tags/v')
    strategy:
      matrix:
        plugin: ${{ fromJSON(needs.detect_plugins.outputs.plugins) }}
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: apk add --no-cache jq

      - name: Build plugin
        env:
          GOOS: wasip1
          GOARCH: wasm
          PLUGIN_DIR: ${{ matrix.plugin }}
          PLUGIN_VERSION: ${{ needs.detect_plugins.outputs.version }}
        run: |
          PLUGIN_DIR_PATH="plugins/$PLUGIN_DIR"
          PLUGIN_JSON="$PLUGIN_DIR_PATH/plugin.json"
          
          # Проверяем существование файлов
          if [ ! -f "$PLUGIN_JSON" ]; then
            echo "ОШИБКА: plugin.json не найден в $PLUGIN_DIR_PATH"
            exit 1
          fi
          
          # Извлекаем имя плагина и обновляем версию
          PLUGIN_NAME=$(jq -r '.name' "$PLUGIN_JSON")
          if [ -z "$PLUGIN_NAME" ] || [ "$PLUGIN_NAME" = "null" ]; then
            echo "ОШИБКА: Имя плагина не найдено в plugin.json для $PLUGIN_DIR"
            exit 1
          fi
          
          # Обновляем версию в plugin.json
          jq --arg version "$PLUGIN_VERSION" '.version = $version' "$PLUGIN_JSON" > "$PLUGIN_JSON.tmp"
          mv "$PLUGIN_JSON.tmp" "$PLUGIN_JSON"
          
          # Собираем плагин
          echo "Building plugin: $PLUGIN_NAME (directory: $PLUGIN_DIR)"
          go build -o "$PLUGIN_DIR_PATH/$PLUGIN_NAME.tgp" -buildmode=c-shared "./$PLUGIN_DIR_PATH"
          
          # Создаём checksum
          sha256sum "$PLUGIN_DIR_PATH/$PLUGIN_NAME.tgp" | awk '{print $1}' > "$PLUGIN_DIR_PATH/$PLUGIN_NAME.sha256"
          
          # Копируем plugin.json с именем плагина
          cp "$PLUGIN_JSON" "$PLUGIN_DIR_PATH/$PLUGIN_NAME.json"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.plugin }}-artifacts
          path: |
            plugins/${{ matrix.plugin }}/*.tgp
            plugins/${{ matrix.plugin }}/*.sha256
            plugins/${{ matrix.plugin }}/*.json

  deploy_all:
    needs: [detect_plugins, build_all]
    runs-on: ubuntu-latest
    container: alpine:latest
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - uses: actions/checkout@v4
      
      - name: Install dependencies
        run: apk add --no-cache jq
      
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Prepare release files
        id: prepare
        env:
          PLUGINS_JSON: ${{ needs.detect_plugins.outputs.plugins }}
        run: |
          mkdir -p "release"
          
          # Обрабатываем каждый плагин и собираем имена для manifest.json
          MANIFEST_NAMES=""
          for PLUGIN_DIR in $(echo "$PLUGINS_JSON" | jq -r '.[]'); do
            # Извлекаем имя плагина из исходного plugin.json
            PLUGIN_JSON_SRC="plugins/$PLUGIN_DIR/plugin.json"
            if [ ! -f "$PLUGIN_JSON_SRC" ]; then
              echo "ОШИБКА: plugin.json не найден для плагина $PLUGIN_DIR" >&2
              exit 1
            fi
            
            PLUGIN_NAME=$(jq -r '.name' "$PLUGIN_JSON_SRC")
            if [ -z "$PLUGIN_NAME" ] || [ "$PLUGIN_NAME" = "null" ]; then
              echo "ОШИБКА: Имя плагина не найдено в plugin.json для $PLUGIN_DIR" >&2
              exit 1
            fi
            
            # Копируем файлы из артефактов
            ARTIFACT_DIR="artifacts/$PLUGIN_DIR-artifacts"
            for EXT in tgp sha256 json; do
              SRC="$ARTIFACT_DIR/$PLUGIN_NAME.$EXT"
              DST="release/$PLUGIN_NAME.$EXT"
              if [ ! -f "$SRC" ]; then
                echo "ОШИБКА: Файл $SRC не найден для плагина $PLUGIN_NAME" >&2
                exit 1
              fi
              cp "$SRC" "$DST"
              echo "$DST"
            done
            
            # Добавляем имя в список для manifest.json
            if [ -z "$MANIFEST_NAMES" ]; then
              MANIFEST_NAMES="\"$PLUGIN_NAME.json\""
            else
              MANIFEST_NAMES="$MANIFEST_NAMES,\"$PLUGIN_NAME.json\""
            fi
          done > release_files.txt
          
          # Создаём manifest.json
          echo "[$MANIFEST_NAMES]" > release/manifest.json
          echo "release/manifest.json" >> release_files.txt
          
          echo "files<<EOF" >> $GITHUB_OUTPUT
          cat release_files.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          files: ${{ steps.prepare.outputs.files }}
          token: ${{ secrets.GITHUB_TOKEN }}
