// Copyright (c) 2020 Khramtsov Aleksei (seniorGolang@gmail.com).
// This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this project source code.
package cleanup

import (
	"bufio"
	"fmt"
	"os"
	"path"
	"strings"

	"tgp/shared"
)

// CleanupGeneratedFiles удаляет все сгенерированные файлы из указанной директории.
// Удаляются .go и .ts файлы, помеченные комментарием doNotEdit.
// Также удаляет подкаталоги (например, jsonrpc), если они содержат только сгенерированные файлы.
func CleanupGeneratedFiles(outDir string) error {
	logger := shared.GetLogger()

	var err error
	var files []os.DirEntry
	if files, err = os.ReadDir(outDir); err != nil {
		logger.Warn(fmt.Sprintf("failed to read directory during cleanup: directory=%s, error=%v", outDir, err))
		return err
	}

	for _, file := range files {
		filePath := path.Join(outDir, file.Name())
		if file.IsDir() {
			// Рекурсивно очищаем подкаталоги
			if err = CleanupGeneratedFiles(filePath); err != nil {
				logger.Warn(fmt.Sprintf("failed to cleanup subdirectory: directory=%s, error=%v", filePath, err))
			}
			// Проверяем, пуста ли директория после очистки
			if isEmpty, _ := isDirEmpty(filePath); isEmpty {
				if err = os.Remove(filePath); err != nil {
					logger.Warn(fmt.Sprintf("failed to remove empty directory during cleanup: directory=%s, error=%v", filePath, err))
				}
			}
			continue
		}

		// Проверяем .go и .ts файлы
		ext := strings.ToLower(path.Ext(file.Name()))
		if ext != ".go" && ext != ".ts" {
			continue
		}

		// Проверяем комментарий doNotEdit в файле
		if genFile, err := os.Open(filePath); err == nil {
			reader := bufio.NewReader(genFile)
			// Читаем первые несколько строк для поиска комментария
			// Комментарий может быть в первой строке или в package comment
			found := false
			for i := 0; i < 10; i++ {
				line, err := reader.ReadString('\n')
				if err != nil {
					break
				}
				// Проверяем, содержит ли строка комментарий doNotEdit
				// Для всех файлов: "GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT."
				if strings.Contains(line, "GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.") {
					found = true
					break
				}
			}
			_ = genFile.Close()

			if found {
				if err = os.Remove(filePath); err != nil {
					logger.Warn(fmt.Sprintf("failed to remove generated file during cleanup: file=%s, error=%v", filePath, err))
				} else {
					logger.Debug(fmt.Sprintf("removed generated file during cleanup: file=%s", filePath))
				}
			}
		}
	}

	return nil
}

// isDirEmpty проверяет, пуста ли директория.
func isDirEmpty(dirPath string) (bool, error) {
	entries, err := os.ReadDir(dirPath)
	if err != nil {
		return false, err
	}
	return len(entries) == 0, nil
}
