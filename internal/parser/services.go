// Copyright (c) 2020 Khramtsov Aleksei (seniorGolang@gmail.com).
// This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this project source code.
package parser

import (
	"go/ast"
	"go/parser"
	"go/token"
	"log/slog"
	"os"
	"path/filepath"
	"strings"

	"tgp/internal/mod"
)

// findServices находит все main файлы в проекте и создает сервисы.
func findServices(log *slog.Logger, project *Project) error {
	goProjectPath := mod.GoProjectPath(project.ContractsDir)
	if goProjectPath == "" {
		goProjectPath = mod.GoProjectPath(".")
		if goProjectPath == "" {
			log.Warn("Failed to find project root, using ContractsDir", "contractsDir", project.ContractsDir)
			goProjectPath = project.ContractsDir
		}
	}

	servicesMap := make(map[string]*Service)

	err := filepath.Walk(goProjectPath, func(filePath string, info os.FileInfo, err error) error {
		if err != nil {
			return nil
		}

		if info.IsDir() {
			if shouldExcludeDir(filePath, goProjectPath, project.ExcludeDirs) {
				return filepath.SkipDir
			}
			return nil
		}

		if shouldExcludeDir(filepath.Dir(filePath), goProjectPath, project.ExcludeDirs) {
			return nil
		}

		if !strings.HasSuffix(info.Name(), ".go") {
			return nil
		}

		if isGeneratedFile(filePath) {
			return nil
		}

		fset := token.NewFileSet()
		file, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
		if err != nil {
			return nil
		}

		var mainFunc *ast.FuncDecl
		for _, decl := range file.Decls {
			if fn, ok := decl.(*ast.FuncDecl); ok && fn.Name != nil && fn.Name.Name == "main" {
				mainFunc = fn
				break
			}
		}

		if mainFunc == nil {
			return nil
		}

		if !isServiceMain(log, file, mainFunc, project) {
			return nil
		}

		serviceName := extractServiceName(filePath, goProjectPath)
		mainPathRel := makeRelativePath(filePath, goProjectPath)
		service := &Service{
			Name:        serviceName,
			MainPath:    mainPathRel,
			ContractIDs: make([]string, 0),
		}

		contractIDs := findContractsInMainFile(log, file, filePath, project)
		service.ContractIDs = contractIDs

		servicesMap[filePath] = service

		return nil
	})

	if err != nil {
		return err
	}

	for _, service := range servicesMap {
		project.Services = append(project.Services, service)
	}

	return nil
}

// extractServiceName извлекает имя сервиса из пути к main файлу.
func extractServiceName(mainPath, projectRoot string) string {
	relPath, err := filepath.Rel(projectRoot, mainPath)
	if err != nil {
		return filepath.Base(filepath.Dir(mainPath))
	}

	name := strings.TrimSuffix(filepath.Base(relPath), ".go")
	if name == "main" {
		name = filepath.Base(filepath.Dir(relPath))
	}

	return name
}

// findContractsInMainFile находит контракты, используемые в main файле.
func findContractsInMainFile(log *slog.Logger, file *ast.File, filePath string, project *Project) []string {
	contractIDs := make([]string, 0)
	contractNames := make(map[string]*Contract)
	for _, contract := range project.Contracts {
		contractNames[contract.Name] = contract
	}

	importAliases := make(map[string]string)
	for _, imp := range file.Imports {
		impPath := strings.Trim(imp.Path.Value, "\"")
		var alias string
		if imp.Name != nil {
			alias = imp.Name.Name
		} else {
			parts := strings.Split(impPath, "/")
			alias = parts[len(parts)-1]
		}
		importAliases[alias] = impPath
	}

	transportAliases := make(map[string]bool)
	for alias, impPath := range importAliases {
		if hasVersionTgConstant(log, impPath, project) {
			transportAliases[alias] = true
		}
	}

	ast.Inspect(file, func(n ast.Node) bool {
		if node, ok := n.(*ast.CallExpr); ok {
			if sel, ok := node.Fun.(*ast.SelectorExpr); ok {
				if transportAlias, ok := sel.X.(*ast.Ident); ok {
					if transportAliases[transportAlias.Name] {
						if contract, exists := contractNames[sel.Sel.Name]; exists {
							contractID := contract.ID
							found := false
							for _, id := range contractIDs {
								if id == contractID {
									found = true
									break
								}
							}
							if !found {
								contractIDs = append(contractIDs, contractID)
							}
						}
					}
				}
			}
		}
		return true
	})

	return contractIDs
}

// isGeneratedFile проверяет, является ли файл сгенерированным.
func isGeneratedFile(filePath string) bool {
	file, err := os.Open(filePath)
	if err != nil {
		return false
	}
	defer file.Close()

	buf := make([]byte, 200)
	n, _ := file.Read(buf)
	content := string(buf[:n])

	return strings.Contains(content, "GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.") ||
		strings.Contains(content, "This file is auto-generated. Do not edit manually.")
}

// isServiceMain проверяет, является ли main файл сервисом.
func isServiceMain(log *slog.Logger, file *ast.File, mainFunc *ast.FuncDecl, project *Project) bool {
	contractNames := make(map[string]bool)
	for _, contract := range project.Contracts {
		contractNames[contract.Name] = true
	}

	transportAliases := make(map[string]string)
	for _, imp := range file.Imports {
		impPath := strings.Trim(imp.Path.Value, "\"")
		var alias string
		if imp.Name != nil {
			alias = imp.Name.Name
		} else {
			parts := strings.Split(impPath, "/")
			alias = parts[len(parts)-1]
		}

		if hasVersionTgConstant(log, impPath, project) {
			transportAliases[alias] = impPath
		}
	}

	if len(transportAliases) == 0 {
		return false
	}

	transportAlias := ""
	for alias := range transportAliases {
		if isTransportUsedInMain(mainFunc, alias, contractNames) {
			transportAlias = alias
			break
		}
	}

	if transportAlias == "" {
		return false
	}

	hasServerCreation := false
	hasContractRegistration := false
	hasListenCall := false

	ast.Inspect(mainFunc.Body, func(n ast.Node) bool {
		if node, ok := n.(*ast.CallExpr); ok {
			if sel, ok := node.Fun.(*ast.SelectorExpr); ok {
				if x, ok := sel.X.(*ast.Ident); ok && x.Name == transportAlias {
					if sel.Sel.Name == "New" {
						hasServerCreation = true
						for _, arg := range node.Args {
							if checkContractRegistration(arg, contractNames, transportAlias) {
								hasContractRegistration = true
								break
							}
						}
					}
				}

				if x, ok := sel.X.(*ast.Ident); ok && x.Name == transportAlias {
					if contractNames[sel.Sel.Name] {
						hasContractRegistration = true
					}
				}

				methodName := sel.Sel.Name
				if methodName == "Listen" || methodName == "Serve" {
					hasListenCall = true
				}
			}
		}
		return true
	})

	return hasServerCreation && hasContractRegistration && hasListenCall
}

// checkContractRegistration проверяет, является ли вызов регистрацией контракта.
func checkContractRegistration(node ast.Node, contractNames map[string]bool, transportAlias string) bool {
	callExpr, ok := node.(*ast.CallExpr)
	if !ok {
		if compLit, ok := node.(*ast.CompositeLit); ok {
			for _, elt := range compLit.Elts {
				if checkContractRegistration(elt, contractNames, transportAlias) {
					return true
				}
			}
		}
		return false
	}

	if sel, ok := callExpr.Fun.(*ast.SelectorExpr); ok {
		if x, ok := sel.X.(*ast.Ident); ok && x.Name == transportAlias {
			contractName := sel.Sel.Name
			if contractNames[contractName] {
				return true
			}
		}
	}

	return false
}

// hasVersionTgConstant проверяет наличие константы VersionTg в пакете.
func hasVersionTgConstant(log *slog.Logger, pkgPath string, project *Project) bool {
	pkgInfo, err := getPackageInfo(log, pkgPath)
	if err == nil && pkgInfo != nil {
		if pkgInfo.MergedFile != nil {
			for _, decl := range pkgInfo.MergedFile.Decls {
				if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.CONST {
					for _, spec := range genDecl.Specs {
						if valueSpec, ok := spec.(*ast.ValueSpec); ok {
							for _, name := range valueSpec.Names {
								if name.Name == "VersionTg" {
									return true
								}
							}
						}
					}
				}
			}
		}
	}
	return false
}

// isTransportUsedInMain проверяет, используется ли transport пакет в main.
func isTransportUsedInMain(mainFunc *ast.FuncDecl, alias string, contractNames map[string]bool) bool {
	hasNewCall := false
	hasContractCall := false

	ast.Inspect(mainFunc.Body, func(n ast.Node) bool {
		if callExpr, ok := n.(*ast.CallExpr); ok {
			if sel, ok := callExpr.Fun.(*ast.SelectorExpr); ok {
				if x, ok := sel.X.(*ast.Ident); ok && x.Name == alias {
					if sel.Sel.Name == "New" {
						hasNewCall = true
					}
					if contractNames[sel.Sel.Name] {
						hasContractCall = true
					}
				}
			}
		}
		return true
	})

	return hasNewCall && hasContractCall
}

// shouldExcludeDir проверяет, нужно ли исключить директорию из анализа.
func shouldExcludeDir(dirPath, projectRoot string, excludeDirs []string) bool {
	if len(excludeDirs) == 0 {
		return false
	}

	relPath, err := filepath.Rel(projectRoot, dirPath)
	if err != nil {
		return false
	}

	relPath = strings.TrimPrefix(relPath, "./")
	relPath = strings.TrimPrefix(relPath, ".\\")
	relPath = filepath.ToSlash(relPath)

	separator := "/"

	for _, excludeDir := range excludeDirs {
		excludeDir = strings.TrimPrefix(excludeDir, "./")
		excludeDir = strings.TrimPrefix(excludeDir, ".\\")
		excludeDir = filepath.ToSlash(excludeDir)

		if relPath == excludeDir {
			return true
		}

		if strings.HasPrefix(relPath, excludeDir+separator) {
			return true
		}
	}

	return false
}
